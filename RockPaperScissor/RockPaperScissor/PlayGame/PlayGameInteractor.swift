//
//  PlayGameInteractor.swift
//  RockPaperScissor
//
//  Created by Ornthita.Eae on 5/7/2566 BE.
//  Copyright (c) 2566 BE ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift HELM Xcode Templates
//  https://github.com/HelmMobile/clean-swift-templates

import Foundation
protocol PlayGameInteractorInput {
    func clickChoice(tag: Int) -> PlayGameScene.Playable
    func restart()
    func getResult()
    func play(request: PlayGameScene.PlayGame.Request)
}

protocol PlayGameInteractorOutput {
    func updateScore(response: PlayGameScene.PlayGame.Response)
    func getResult(result:String,bot:String,player:String)
}

protocol PlayGameDataSource {
    
}

protocol PlayGameDataDestination {
    
}

class PlayGameInteractor: PlayGameInteractorInput, PlayGameDataSource, PlayGameDataDestination {
    
    var output: PlayGameInteractorOutput?
    var player: PlayGameScene.Playable = PlayGameScene.Playable()
    var bot: PlayGameScene.Playable = PlayGameScene.Playable()

    var viewModel = PlayGameScene.PlayGame.ViewModel(result: "")
    
    var botScore = 0
    var playerScore = 0
//    var botProcess = ""
//    var playerProcess = ""
    
    
    // MARK: Business logic
    
}

extension PlayGameInteractor {

    func play(request: PlayGameScene.PlayGame.Request) {
        let randVal = Int.random(in: 0...PlayGameScene.Choices.allCases.count-1)
        player = clickChoice(tag: request.sign)
        bot = clickChoice(tag: randVal)
        
        player.score = playerScore
        bot.score = botScore
        
        if let bSc = bot.choice?.rawValue , let pSc = player.choice?.rawValue {
            let response = calScore(botCh: bSc, playerCh: pSc)
            print(response)
            update(response: response)
        }
        getResult()
        //clearState()
    }

    func restart() {
        botScore = 0
        playerScore = 0
        let response = PlayGameScene.PlayGame.Response(botScore: botScore, playerScore: playerScore, botProcess: "Thinking..", playerProcess: "Thinking..")
        viewModel.result = ""
        update(response: response)
        
    }
    
    func clickChoice(tag: Int) -> PlayGameScene.Playable {
        guard let choice = PlayGameScene.Choices(rawValue: tag) else {
            return PlayGameScene.Playable()
        }
        return setPlayer(to: choice)
    }
    
    func setPlayer(to ch: PlayGameScene.Choices) -> PlayGameScene.Playable {
        var player: PlayGameScene.Playable = PlayGameScene.Playable()
        switch ch {
        case .rock :
            player.choice = .rock
            player.process = "ROCK!"
            
        case .paper :
            player.choice = .paper
            player.process = "PAPER!"
            
        case .scissors :
            player.choice = .scissors
            player.process = "SCISSORS!"
        }
        return player
    }
    
    func calScore(botCh: Int , playerCh: Int) -> PlayGameScene.PlayGame.Response {
        if botCh == playerCh {
            viewModel.result = "DRAW"
        }
        else if botCh == 0 {
            if playerCh == 1 {
                viewModel.result = "Player WIN"
                playerScore += 1
            } else {
                viewModel.result = "Bot WIN"
                botScore += 1
            }
        }
        
        else if botCh == 1 {
            print("bot paper")
            if playerCh == 2 {
                print("player scissor")
                viewModel.result = "Player WIN"
                playerScore += 1
            } else {
                print("player rock")
                viewModel.result = "Bot WIN"
                botScore += 1
            }
        }
        
        else if botCh == 2 {
            print("bot scissor")
            if playerCh == 0 {
                print("player rock")
                viewModel.result = "Player WIN"
                playerScore += 1
            } else {
                print("player paper")
                viewModel.result = "Bot WIN"
                botScore += 1
            }
        }
        return PlayGameScene.PlayGame.Response(botScore: botScore, playerScore: playerScore, botProcess: bot.process, playerProcess: player.process)
    }
    
    func update(response: PlayGameScene.PlayGame.Response) {
        output?.updateScore(response: response)
    }
    
    func getResult() {
        output?.getResult(result: viewModel.result,bot: bot.process,player: player.process)
    }
    
}

